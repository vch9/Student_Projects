#+OPTIONS: ^:nil

               *Compilation -- Master 1 Paris Diderot -- 2019-2020*

(Note: sous Emacs, utiliser [TAB] pour ouvrir/fermer les sections.)

* Cours 1 "Introduction" <2019-09-09>
** Présentation
   Adrien Guatto guatto@irif.fr
   Yann Régis-Gianas yrg@irif.fr
** Ce que vous allez apprendre ici et pourquoi.
*** Le sujet affiché
   - Écrire un compilateur, un traducteur d'un langage de
     programmation vers un autre, typiquement, d'un langage de
     haut-niveau vers un langage assembleur.
*** Le sujet caché
**** Deux semestres pour un premier "gros" projet de programmation
     - 7 jalons en S1 et 4 jalons en S2
     - Des outils de développement: générateur de codes, gestionnaire
       de version, intégration continue, ...
     - La méthodologie nécessaire pour travailler sur un projet réaliste.
**** La compilation est un sujet pluridisciplinaire!
     - Ecrire un compilateur n'est pas une compétence immédiatement
       utilisable professionnellement.
     - Mais c'est un prétexte pour:
       - Apprendre à écrire un analyseur syntaxique, un analyseur statique, etc.
       - Mieux comprendre la sémantique des langages de programmation.
       - Mettre en pratique les cours d'architecture des machines, le
	 cours de théorie des graphes, le cours de théorie des langages,
	 de logiques, de sémantique, génie logiciel, méthodes formelles ...
**** Écrire un compilateur fera de vous de meilleurs programmeurs
** Fonctionnement du cours
*** Un cours orienté "projet" et "inversé"
    - Le cours est centré sur la réalisation du projet : elle dirige
      les concepts et les discussions abordés lors des séances de
      cours.
    - Le code du projet est un code à trou : il faudra lire autant
      qu'écrire!
    - Vous aurez les sujets des jalons très rapidement.
*** Ce que l'on attend de vous
    - Un travail continu, une attitude pro-active et une approche méthodique :
      - Un jalon à rendre toutes les trois semaines, testé automatiquement.
      - Des questions à poser régulièrement.
      - Une attention particulière aux indications de méthodologie!
      - En cours: prise de notes, pensée critique, poser des questions
      - En TP: poser des questions sur le jalon, discuter avec l'enseignant et entre vous
      - Chez vous: lire (!), programmer
    - Votre compréhension du projet sera évaluée individuellement en
      soutenance (70% de la note) et à l'écrit (30% de la note).
    - Un intérêt particulier donné à la qualité du code.
    - En soutenance, on valide aussi votre capacité à expliquer votre code.
*** Témoignages d'étudiants
**** Etudiant 1
     "Je n'ai jamais autant programmé mais j'ai beaucoup appris!"
**** Etudiant 2
     "Les tests automatiques, c'est génial!"
**** Etudiant 3
     "Le Caml, c'était vraiment pas mon truc, mais ça c'était avant."
**** Etudiant 4
     "Maintenant, je comprends vraiment ce qui se passe quand mon
      programme Java, Python, C ou Caml s'exécute!"
**** Etudiant 5
     "Au début, j'avais peur de M. Régis-Gianas et M. Guatto.
     Maintenant, ils me font toujours peur mais pour d'autres raisons."
**** Etudiant 6
     "Après ce cours, j'ai créé mon propre langage de programmation!"
*** Calendrier, horaires et équipes enseignantes
**** Enseignants
    - Semestre 1: Peter Habermehl en TD, Adrien Guatto et YRG en cours.
    - Semestre 2: Adrien Guatto en TD, YRG en cours.
**** Horaires
    - Semestre 1: Cours: Lundi 13h30 - 15h30, salle 2035 / TP : Mardi 8h30 2032
**** Calendrier
|----+------------+---------------+--------------+---------+-----------------|
|  # |       Date | Enseignant    | Cours        | TD      | Deadline jalons |
|----+------------+---------------+--------------+---------+-----------------|
|  1 | 2019-09-09 | Yann & Adrien | Introduction |         |                 |
|  2 | 2019-09-16 | Yann          | Parsing LR   | Jalon 1 | +3 semaines     |
|  3 | 2019-09-23 | Adrien        | Sém S/D 1    |         |                 |
|  4 | 2019-09-30 | Adrien        | Sém S/D 2    | Jalon 2 | +3 semaines     |
|  5 | 2019-10-07 | Adrien        | Sém S/D 3    | Jalon 3 | +3 semaines     |
|  6 | 2019-10-14 | Yann          | x86/Retrolix | Jalon 4 | +3 semaines     |
|  7 | 2019-10-21 | Yann          | Fopix        | Jalon 5 | +3 semaines     |
|  8 | 2019-10-28 | Yann          | Hobix        | Jalon 6 | +3 semaines     |
|  9 | 2019-11-04 | Yann          | Hopix        | Jalon 7 | +3 semaines     |
|    | 2019-11-11 | FERIE         |              | soutien |                 |
| 10 | 2019-11-18 | Adrien        |              |         |                 |
| 11 | 2019-11-25 | Adrien        |              | soutien |                 |
| 12 | 2019-12-02 | Yann & Adrien |              | soutien |                 |
|----+------------+---------------+--------------+---------+-----------------|
** Un mini-compilateur
   - Voir le fichier [file:doc/cours-01/code/marthe.ml]
** Survol de OCamllex et Menhir
   - Spécification d'analyseurs lexicaux
   - Fonctionnemenent d'OCamllex
   - Spécification de grammaires
   - Fonctionnement de Menhir
** Devoirs
*** TODO Faire les actions décrites dans le README.md
*** TODO Lire la documentation de ocamllex
     [[https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html]]
*** TODO Lire la documentation de menhir
     [[http://pauillac.inria.fr/~fpottier/menhir/manual.pdf]]
*** TODO Vérifier son environnement de développement *avant* le TP
*** TODO Faire les exercices de marthe.ml

* Cours 2 "Analyse syntaxique LR" <2019-09-16>
** FAQ
** Environnement OCaml
   - OPAM 2.0
   - utop, dune, merlin, menhir
** Rappels des définitions standards de l'analyse grammaticale
   - Grammaire

     Impo

     T = num = { 0, 1, ... }
       ∪ { while, if, then, else, nop }
       ∪ { :=, ; }
       ∪ id = { x, y, z, ... }
       ∪ { # }

     N = { P, C, E }

     S = P

     R =
       P → C #
       C → while E C
       C → if E then C else C
       C → if E then C
       C → C ; C
       C → id := E
       E → id
       E → num

     R en notation Backus Naur Form (BNF)

       P ::= C #
       C ::= while E C | if E then C else C | if E then C | C ; C | id := E | nop
       E ::= id | num

   - Dérivation

     while x x := 0 #

     P
     → C #
     → while E C #
     → while id C #
     → while id id := E #
     → while id id := num #

     On attache des *valeurs sémantiques* aux symboles terminaux pour
     pouvoir avoir des ensembles "infinis" de terminaux.

     nop ; nop ; nop #

     P
     → C #
     → C ; C #
     → C ; C ; C #   (* En récrivant la première occurrence de C)
     → nop ; C ; C #
     → nop ; nop ; C #
     → nop ; nop ; nop #

   - Langage

     L(G) = { w ∈ T⋆ | S →⋆ w }

   - Arbre de dérivation

     2 arbres pour le même mot = la grammaire est ambigue.
     Parfois, la sémantique est insensible à cette ambiguité... mais parfois non!

   - Arbre de syntaxe concrète
   - Arbre de syntaxe abstraite
     Voir [file:cours-02/definitions.pdf]
** La pratique
*** OCamlLex
    https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html
*** Menhir
    http://gallium.inria.fr/~fpottier/menhir/manual.pdf
** Comment ça marche?
   - L'analyse syntaxe ascendante
     Voir [file:cours-02/bottom-up-parsing.pdf]
   - LR(0)
   - LR(1)
   - LALR(1)
     Voir [file:cours-02/lr1.pdf]
* Cours 3 "Introduction à la sémantique et au typage 1" <2019-09-23>
  Voir les transparents.
* Cours 4 <2019-09-30>
  Voir les transparents.
* Cours 5 <2019-10-07>
  Voir les transparents.
* Cours 6 "Compilation de Hopix vers x86-64" <2019-10-14>
** Objectifs
   - Vous emmener de Hopix jusqu'au langage machine!
   - Programmer en assembleur et générer de l'assembleur pour votre propre machine.
   - Comprendre les conventions qui rendent possibles l'interopérabilité entre
     les composants logiciels.
   - Prendre conscience des différences de performances entre le code interprété,
     le code compilé naïvement et le code optimisé.
   - Raffiner votre connaissance du "coût de l'abstraction" dans les langages de
     haut-niveau, typiquement ceux d'ordre supérieur.
   - Objectifs pour ce semestre : Hopix vers x86-64
   - Pour le second semestre : optimiser le code généré.
** Vue d'ensemble du compilateur

    - La chaîne de compilation :

                  Hopix → Hobix → Fopix → Retrolix → x86-64

    - Nous allons construire le compilateur à l'envers, de l'assembleur vers Hopix.

*** Hopix vers Hobix

fun len (l) =
   switch (l) {
   | Nil -> 0
   | Cons (_, xs) -> 1 + len (xs)
   }

devient en Hobix:

def len (l) =
   if l[0] = 0 then
     0
   else
     let xs = l[2] in
     1 + len (xs)

*** Hobix vers Fopix

def add (x) =
    let z = 2 * x in
    fun (y) -> x + y * z

devient

def anomymous (y, env) =
    env[2] + y * env[1]

def add (x) =
    let z = 2 * x in
    [ ptr_code(anonymous) ; z ; x ]

*** Fopix vers Retrolix

def fact (n) =
    if n = 0 then 1 else n * fact (n - 1)

devient

def fact ()
    locals tmp
    l0: cmp %rdi, 0 -> l1, l2
    l1: mov %rax, 1 -> l3
    l3: ret
    l2: tmp <- %rdi -> l4
    l4: %rdi <- %rdi - 1 -> l5
    l5: call fact -> l6
    l6: %rax <- mul tmp, %rax -> l7
    l7: ret
** x86-64
*** Quelques éléments de contexte
   - Instruction Set Architecture (ISA) = abstraction
   - Micro-architecture = techniques d'implémentations d'une ISA
   - Deux styles d'ISA : RISC vs CISC.
     RISC: petit nombre d'instructions orthogonales / distinction instructions arith., logique et mémoire.
     CISC: grand nombre d'instructions
   - Frise historique

		       8086 (16bits)    x86 (32bits)    AMD64 (64bits)
	     |—————————————|——————————————|———————————————|—————————————|————————–→
	    1970          1980           1990           2000          2010

   - Avantages : répandu, rétrocompatible, performant
   - Inconvénients : complexe et baroque
   - Références : notes d'Andrew Tolmach, ISA réduit, spécifications d'Intel
   - Pour regarder différents compilateurs à l'oeuvre et apprendre à lire du x86:
     https://godbolt.org/#
*** État du processeur
    - registres:
      %rax, %rbx, %rcx, %rdx, %rbp, %rsp, %rdi, %rsi, %r8, %r9, %r10, %r11, ..., %r15
    - mémoires (dont la pile)
    - little-endian/petit-boutien: https://fr.wikipedia.org/wiki/Endianness
    - %ax ⊂ %eax ⊂ %rax
    - %rip : compteur de programme
    - %rflags : champ de bits, information sur les résultats arithmétiques
    - OFFSET(BASE, INDEX, SCALE)
      OFFSET est une valeur immédiate
      BASE est un registre
      INDEX est un registre, optionnel
      SCALE est une valeur dans { 1, 2, 4, 8 }, optionnel
      = OFFSET + BASE + INDEX * SCALE
    - mov SRC, DST
      attention: on ne peut pas aller de la mémoire à la mémoire.
      variantes: movq, movl, movw, movb  (b = 8, w = 16, l = 32, q = 64)
    - NB: Il y a deux syntaxes pour écrire du code ASM x86-64: Intel et GNU. Nous
      suivons la syntaxe GNU. En Intel, SRC et DST sont inversés.
    - exemples:
      - movq $42, %rax         # %rax <- 42
      - movq %rbx, -8(%rsp)    # MEM[%rsp - 8] <- %rbx
    - Pile en x86-64 // System V
      - %rsp: pointeur de pile
      - La pile croît vers le bas
      - %rsp doit être un multiple de 8
      - %rbp pointeur de cadre (frame-pointeur)
      - Pour travailler sur la pile, on utilise push/pop.
      - pushq %rax est équivalent à
	  subq $8, %rsp
	  movq $rax, (%rsp)
	ou
	  movq $rax, -8(%rsp)
	  subq %8, %rsp
     - rflags, à quoi ça sert?

       |-----+-----------------+------------|
       | bit | signification   | mnémonique |
       |-----+-----------------+------------|
       |   0 | Retenue         | CF         |
       |   1 | Parité          | PF         |
       |   6 | Zéro            | ZF         |
       |   7 | Signe (1 = neg) | SF         |
       |  11 | Overflow        | OF         |
       |-----+-----------------+------------|

     - cmpq SRC1, SRC2
       -> calcule SRC2 - SRC1, ignore le résultat mais met à jour rflags.

     - je foo
       -> sauter à "foo" si ZF est allumé

     - jmp foo
       -> saut inconditionnel à foo

     - jmp *%rax
       -> saut à l'adresse de code contenu par rax

     - Il faut que $rsp+8 soit aligné sur 16 octets

** Exemples de programmes x86-64
*** Factorielle itérative
    On écrit le code de factorielle dans un style itératif, avec une boucle. Le
    code C, pour se fixer les idées :

    int64_t fact(int64_t n) {
      int64_t res = 1;
      while (n > 1) {
        res *= n--;
      }
      return res;
    }
**** Solution
     fact:   movq $1, %rax
     fact0:  cmp $1, %rdi
             jle fact1
             imulq %rdi, %rax
             dec %rdi
             jmp fact0
     fact1:  ret

*** Fonction principale
    On souhaite appeler printf() pour afficher le résultat de fact(6). Attention
    aux contraintes d'alignement de l'ABI System V !

**** Solution
    .global main
    main:   subq $8, %rsp
            movq $6, %rdi
            call factr
            movq $msg, %rdi
            movq %rax, %rsi
            call printf
            movq $0, %rdi
            call exit

*** Factorielle récursive naïve.
    On écrit le code de factorielle dans un style récursif naïf, l'équivalent du
    code OCaml suivant :

    let rec fact n = if n <= 1 then 1 else n * fact (n - 1)

**** Solution

     En écrivant du code mécaniquement, comme un compilateur un peu naïf, on
     obtient l'assembleur ci-dessous.

     factr:  pushq %rbp
             movq %rsp, %rbp
             subq $8, %rsp
             cmp $1, %rdi
             jle factr0
             movq %rdi, -8(%rbp)
             dec %rdi
             call factr
             imulq -8(%rbp), %rax
             addq $8, %rsp
             popq %rbp
             ret
     factr0: movq $1, %rax
             addq $8, %rsp
             popq %rbp
             ret

     Note : on a négligé la contrainte d'alignement de la pile à chaque call, ne
     respectant pas strictement l'ABI System V. Ce n'est pas gênant dans la
     mesure où on appelle jamais de fonction de la bibliothèque standard ici.

** De Retrolix à x86-64
*** Retrolix
    Le code relatif à Retrolix est contenu dans src/retrolix/. Commencer par
    lire l'AST présent dans retrolixAST.ml, puis en cas de question, regarder la
    sémantique de référence dictée par l'interprète dans retrolixInterpreter.ml.

    Il s'agit d'un langage presque aussi bas niveau que l'assembleur, mais pas
    tout à fait. Quelques caractéristiques :

    - des registres (x86-64) *et* des variables (locales, globales, paramètres),

    - le registre matériel %r15 est réservé (jamais utilisé),

    - respecte la convention d'appel en ce qui concerne les registres (registres
      caller-save vs. callee-save, registre stockant la valeur de retour),

    - un jeu d'instruction bas niveau.

    /!\ Les six premiers arguments sont passés par %rdi, %rsi, etc. Donc les
    arguments déclarés et passés explicitement en Retrolix n'apparaîssent que
    dans les fonctions avec strictement plus de six arguments. /!\

*** x86-64

    Le code est contenu dans src/x86-64/, et l'AST qui nous intéresse est dans
    x86_64_AST.ml. Pas d'interprète ou parser.

    Remarque : comme on utilise GCC pour l'assemblage et l'édition de liens, nos
    programmes assembleurs doivent disposer d'une fonction main().

    /!\ L'AST est *trop permissif* ! Il permet d'écrire du code qui n'assemble
    pas, par exemple "movq (%rsp), (%rsp)". Éviter de générer ce genre de code
    fait partie de votre travail. /!\

*** Différences entre Retrolix et x86-64

    - des chaînes litérales en Retrolix,

    - en Retrolix, pas de fonction main(), le point d'entrée du programme est la
      séquence des blocs d'initialisation de ses variables globales,

    - pas de variables en x86-64,

    - jeu d'instructions assez différent : Retrolix est plutôt RISC mais x86-64
      est très CISC ; par exemple :

      * trois adresses vs. deux adresses,

      * modes d'adressage et opérandes mémoires limités en x86-64,

      * bizarreries en x86-64, par exemple la division.

*** Traduire Retrolix vers x86-64

    Certaines des différences que nous venons de décrire ne sont pas
    essentielles, et sont donc déjà traitées pour vous (chaînes litérales,
    génération d'un main, ...). On va se concentrer sur deux points :

    - la traduction des constructions Retrolix en assembleur x86-64,

    - la gestion des variables et de la pile.

    La passe de traduction est dans src/x86-64/retrolixToX86_64.ml. Vous devez
    remplacer les [failwith "Students! ..."] avec le code approprié.

    Il s'agit essentiellement d'implémenter deux modules, MyInstructionSelector
    et MyFrameManager. Le premier se charge de la traduction de construction
    atomiques de Retrolix en x86-64, le second de la gestion de la pile et des
    variables. Le second va naturellement faire appel au premier.

    /!\ Dans ce jalon, on se concentrera sur la *correction* du code généré, et
    on ne cherchera pas nécessairement à optimiser la traduction. On reviendra
    sur l'optimisation ultérieurement. /!\

**** Points à gérer
***** Bases de la gestion de la pile

      Considérons la fonction ci-dessous.

      def f(x, y)
      local a, b, c:
        ...
      end

      En suivant l'ABI System V, à quoi doit ressembler son cadre de pile après
      l'exécution de son prologue ? Quel est le code du prologue, d'ailleurs ?
      De l'épilogue ?

****** Indications

     Prologue :

       pushq %rbp
       movq %rsp, %rbp
       subq $24, %rsp

     Épilogue :

       addq $24, %rsp
       popq %rbp
       ret

     Disposition de la pile :

     | cadre parent |        |
     |--------------+--------|
     | arg y        |        |
     | arg x        |        |
     | saved %rip   |        |
     | saved %rbp   | <- rbp |
     | var a        |        |
     | var b        |        |
     | var c        | <- rsp |

     Notons que l'ABI nous laisse le choix de l'ordre des variables locales.

***** Bases de la traduction

      Comment traduire les instructions Retrolix suivantes ?

        %rax <- load 42;

        %rax <- add %rax, %rbx;

        %rax <- add %rbx, %rcx;

        %rax <- div %rbx, %rcx;

      Comment traduire l'instruction suivante, si a est une variable locale ? Un
      paramètre ? Une variable globale ?

         a <- load 42;

      Dans les instructions ci-dessous, on se place dans le corps d'une fonction
      dont les variables locales sont a, b et c, déclarées dans cet ordre.

         a <- load 42;

         %rax <- add %rax, a;

         a <- add a, %rax;

         a <- add a, b;

         a <- add b, c;

***** Convention d'appel

      Comment traduire les appels de fonction ?

      def f()
        call g(23, %rax, %rbx)

* Cours 7 "Compilation de Fopix vers Retrolix" <2019-10-21>
** Présentation de Fopix
    Lecture de l'AST Fopix présent dans le fichier fopix/fopixAST.ml.
** Fopix et Retrolix, similarités et différences
**** Similarités
     Langages de premier ordre avec possibilité de saut indirect.

     Litéraux identiques.
**** Différences
     Retrolix a des registres machines.

     Retrolix suit la convention d'appel machine.

     Fopix est un langage à base d'expressions de profondeur arbitraire plutôt
     que d'instructions au format trois adresses.

     Fopix a des && et des || court-circuits.

     Fopix dispose d'instructions de gestion du flot de contrôle structurées.

     Fopix a des déclarations locales internes aux fonctions, tandis que
     Retrolix ne dispose que d'un espace de nom pour toute fonction (ou
     initialiseur de variable globale).

     Plus subtil : Fopix accède à la mémoire à travers des blocs. La syntaxe
     concrète des affectations prend la forme

       block_e[index_e] := val_e

     tandis que les déréférences prennent la forme

       block_e[index_e].

     Ces constructions sont traduites vers des appels à write_block() et
     read_block() dans la syntaxe abstraite, cf. fopixInterpreter.ml.

** Quelles sont les difficultés de la traduction de Fopix en Retrolix ?
**** Passage des expressions au code à trois adresses ; structures de contrôle
     Comment compiler vers Retrolix les expressions Fopix suivantes ?

     On pourra supposer que le résultat de chaque expression doit être stocké
     vers une variable locale baptisée "r" et, bien sûr, utiliser autant de
     variables locales que nécessaire (elles sont là pour ça).

     À ce stade, on ne cherche pas *du tout* à optimiser le code, mais plutôt à
     trouver un schéma de compilation mécanique qui soit facile à implémenter.

     (Les quatre expressions ci-dessous sont indépendantes.)

     1 - (3 * 4)

     x >= 0

     if x = 0 then 0 else y / x

     (while (x[0] >= 0) (x[0] := x[0] - 1)); x[0]
***** Solutions
      Toute instruction Retrolix doit être précédée d'une étiquette, mais on les
      omet ci-dessous les étiquettes superflues. Tous les r_i sont des variables
      locales préalablement déclarées.

      Premier exemple :

        r1 <- copy 1;
        r2 <- copy 3;
        r3 <- copy 4;
        r4 <- mul r2, r3;
        r  <- add r1, r4;

      Deuxième exemple :

            r1 <- copy 1;
            r2 <- copy x;
            r3 <- eq r1, r2;
            jumpif eq r3, 0 -> lE, lT
        lT: r <- copy 0;
            jmp lK:
        lE: r4 <- y;
            r5 <- x;
            r <- div r4, r5;
        lK:

      Troisième exemple :

        lT: r1 <- read_block(x, 0);
            r2 <- copy 0;
            r3 <- gte r1, r2;
            jumpif eq r3, 0 -> lK, lB
        lB: r4 <- read_block(x, 0);
            r5 <- sub r4, 1;
            write_block(x, 0, r5);
            jump lT
        lK: r <- read_block(x, 0);

      Remarque : ces solutions sont volontairement naïves. Un attrait des
      compilateurs optimisants est de permettre, au moins dans une certaine
      mesure, de séparer la correction de l'efficicacité. Concrètement, on peut
      générer du code naïf simple qui sera optimisé par une passe ultérieure.


** Détails de la traduction
**** Les variables locales et le masquage
     Comment traduire le programme Fopix suivant ?

     val x = 1;
     val y = (val a = 3; a);
     val z = y + x;
     z

     x <- copy 1
     a <- copy 3
     y <- copy a
     z <- y + x;
     z

***** Solution
      x0 <- copy 1;
      x1 <- copy 3;
      y  <- copy x1;
      z  <- add y, x0;
      r  <- copy z;
**** Les convention d'appel
     Réflechissons à la traduction en Rétrolix du programme Fopix ci-dessous.

     def fib(n) =
       if n <= 0 then 0
       else if n = 1 then 1
       else fib (n - 1) + fib (n - 2)

***** Solution

      def fib():
      locals x, r00, r01, ..., r12:
             x <- copy %rdi;
             r00 <- copy x;
             r01 <- copy 0;
             r02 <- lte r00, r01;
             jumpif eq r2, 0 -> lE1, lT1;
        lT1: r03 <- copy x;
             r04 <- copy 1;
             r05 <- eq r03, r04;
             jumpif eq r05, 0 -> lE2, lT2;
        lT2: r06 <- copy x;
             r07 <- copy 1;
             %rdi <- sub r06, 1;
             fib();
             r08 <- copy %rax;
             r09 <- copy x;
             r10 <- copy 2;
             %rdi <- sub r09, r10;
             fib();
             r11 <- copy %rax;
             r12 <- add r08, r11;
             r <- copy r12;
             jump lK2;
        lE2: r <- copy 1;
        lK2: jump lK1;
        lE1: r <- copy 0;
        lK1: %rax <- copy r;
             ret;
      end
* Cours 8 "Explication des fermetures" <2019-10-21>
** Présentation de Hobix
    - Voir [file:src/hobix/hobixAST.ml]
** Les différences entre Hobix et Fopix
    - Fopix distingue les fonctions et les valeurs, Hobix non.
    - Les littéraux de Hobix sont les mêmes que Fopix, sauf les pointeurs de fonction.
** L'explication des fermetures

Comment traduire les programmes OCaml suivant en C?

**** Rappel: une fonction, ce n'est pas juste un pointeur.

let f0 z =
  let y = z * 2 in
  fun x -> x + y + z

***** Traduction

      C(fun (x₁, ..., xₙ) -> e) = <<
        val c = allocate_block (1 + m)
        c[0] := &code
        c[1] := y₁
        ...
        c[m] := yₘ
      >>
      where FV(fun (x₁, ..., xₙ) -> e) = { y₁, ..., yₘ}
      where code is such that:
      <<
      def code (closure, x₁, ..., xₙ) = C(e)
      >>

**** Application = auto-application d'une fermeture

let test0 = f0 3

let apply f x = f x

     C(a b) = <<
        val c = C(a);
        val e = C(b);
        c[0] (c, e)
     >>

**** La récursion simple

let rec repeat n f =
  if n = 0 then () else (f n; repeat (n - 1) f)

let test1 = repeat 3 (fun x -> x + 1)

let test2 = repeat 5 (f0 2)

***** Solution 1
      Mimer l'interpréteur en produisant des fermetures cycliques où
      les occurrences récursives sont vues comme des variables libres.

***** Solution 2
      Comme on compile la fonction repeat, on connait le nom de la
      fonction fopix qui réalise son code : il suffit de l'appeler
      directement.

**** La récursion mutuelle

let repeat_alt n f =
  let rec odd k =
     if k < 0 then () else (f true; even (k - 1))
  and even k =
     if k < 0 then () else (f false; odd (k - 1))
  in
  if n mod 0 = 0 then even n else odd n

  - Les solutions sont similaires au cas d'une simple fonction récursive.
  - On peut aussi faire comme OCaml et produire une unique fermeture
    qui partage les pointeurs de toutes les fonctions mutuellement
    récursives et l'union des variables libres de ces fonctions.

* Cours 9 "Révisions" <2019-11-04>
** de Hopix à Hobix
   - C(K(e₁, ⋯, eₖ)) =
     construire un bloc de taille k+1 et utiliser un (petit) entier
     pour représenter l'étiquette L.
   - C(case e of p₁ → e₁ | ⋯ | pₖ → eₖ) =
	if "e matches p₁" then e₁
	else if "e matches p₂" then e₂
	else ...

     3 problèmes ici:
     - que faire lorsque tous les motifs ont été consommés?

     - comment lier les variables des patterns?

     - comment ne pas évaluer e plusieurs fois?

     Nouvelle proposition

     C(case e of p₁ → e₁ | ⋯ | pₖ → eₖ) =
        val v = C(e) in
        if "v matches p₁" then
          let "p₁ binds subvalues of v" in
          C(e₁)
        else if ...
        else

     fun (x) => case x of None -> 0 | Some [] -> 0 | Some [a] -> a

     fun (x) =>
        if x[0] = 0 then
          0
        else if x[0] = 1 && x[1][0] = 0 then
          0
        else if x[0] = 1 && x[1][0] = 1 && x[1][2][0] = 0 then
          val a = x[1][1];
          a
        else goto_hell ()


*** Compilation des valeurs étiquetées
*** Compilation naïve du pattern-matching
**** Expansion élégante des noeuds disjonctifs
     Voir la monade de liste.

** Travaux dirigés

#+BEGIN_SRC ocaml
(* HOPIX *)
type list = Nil | Cons (int, list)

fun fun_of_list l =
 switch (l) {
 | Nil () -> \x -> false
 | Cons (y, ys) ->
   let d = fun_of_list ys;
    \x -> (x =? y) || d x
 }

let d = fun_of_list (Cons (1, Nil)) 4

(* HOBIX *)
fun fun_of_list l =
  if l[0] = 0 then \x -> false
  else if l[0] = 1 then
    let y = l[1];
    let ys = l[2];
    let d = fun_of_list ys;
    \x -> ((x =? y) || d x)

let d =
  fun_of_list (
  let b = newblock 3;
  b[0] := 1;
  b[1] := 1;
  b[2] := newblock 1;
  b[2][0] := 0; b
  ) 4

(* FOPIX *)

(* Le code de "\x -> false". *)
fun anonfun_1 (env, x) = false

fun anonfun_2 (env, x) =
  (x =? env[1]) || env[2][0] (env[2], x)

fun fun_of_list l =
  if l[0] = 0 then
    let closure = newblock 1;
    closure[0] := &anonfun_1;
    closure
  else if l[0] = 1 then
    let y = l[1];
    let ys = l[2];
    let d = fun_of_list ys;
    let closure = newblock 3;
    closure[0] := &anonfun_2;
    closure[1] := y;
    closure[2] := d;
    closure


#+END_SRC ocaml

** Les différents choix de représentation des fermetures
*** Copie vs partage
*** Optimisation des fermetures mutuellement récursives
<<<<<<< HEAD
* Cours 10 "De Hopix à Hobix, en grands détails" <2019-11-18>
=======
* Cours 10 "De Hopix à Hobix, en grands détail" <2019-11-18>
>>>>>>> Cours 12
** Introduction
   Durant la première moitié du cours, nous avons construit les parties hautes
   (/frontend/) d'un compilateur Hopix, composé d'un analyseur lexical (/lexer/)
   et syntaxique (/parser/) ainsi que d'un typeur.

   Durant la seconde moitié, nous avons construit les parties basses d'un
   compilateur générant de l'assembleur x86-64. Cette construction s'est
   déroulée de manière ascendante : x86-64 depuis Retrolix, Retrolix depuis
   Fopix, et dernièrement Fopix depuis Hobix.

   Ce cours discute du dernier jalon du projet, qui connecte partie haute et
   partie basse en réalisant la traduction de Hopix en Hobix.
** Rappels sur Hopix et Hobix
   Hobix est un langage fonctionnel d'ordre supérieur permettant la manipulation
   de plusieurs sortes de données structurées :
   - types algébriques (sommes nommées) et filtrage de motifs,
   - types enregistrements (produits nommés) et projections de leurs champs,
   - références modifiables avec création/écriture/lecture.

   Hobix ne disposant pas de tels types de données, ceux-ci doivent être
   implémenté par leurs représentations mémoire explicite. La mémoire, en Hobix,
   est structurée comme un ensemble fini de *blocs* manipulés par les primitives
   explicites _allocate_block()_, _read_block()_ et _write_block()_.

   De plus, Hopix dispose d'une boucle comptée (boucle ~for~) en plus de la
   boucle ~while~ générale, tandis que Hobix ne dispose que de cette dernière.

   Traduire Hopix en Hobix consiste donc à éliminer les constructions superflues
   en les réduisant à des fonctionnalités plus primitives : blocs mémoires pour
   les types structurés et boucle ~while~ pour la boucle ~for~.

   On va commencer par la traduction des références. À partir de maintenant, si
   ~e~ est une expression Hopix, on écrira 〚 ~e~ 〛 pour l'expression Hobix
   traduite correspondante.
** Élimination des références
   Pour exprimer les références (ainsi que les types de données structurés) en
   termes des primitives de manipulation de bloc de Hobix, on va commencer par un
   rappel sur les dits blocs.
*** Rappels sur les blocs mémoire
    Un *bloc* mémoire, dans Hobix et les langages ultérieurs de la chaîne de
    compilation, est une zone de mémoire contiguë. On peut la voir comme un
    tableau contenant N cases, où N est la taille du bloc fixée à l'allocation.

    |--------+--------+--------+-----+----------|
    | Case 0 | Case 1 | Case 2 | ... | Case N-1 |
    |--------+--------+--------+-----+----------|

    Chaque case contient une *valeur* Hobix, définie comme un entier 64 bits.

    L'utilisation d'entiers 64 bits est suffisante pour représenter toutes les
    données qui nous intéressent : entiers, caractères et pointeurs (vers des
    chaînes, des blocs, etc.). Hobix n'étant pas typé, on ne distingue pas
    statiquement les entiers des pointeurs, et les champs des blocs peuvent donc
    stocker entiers ou pointeurs selon nos besoins.

    On rappelle que les primitives permettant de manipuler les blocs sont les
    suivantes :

    - _allocate_block(n)_, qui alloue un bloc de taille _n_,

    - _read_block(p, i)_, qui renvoie le contenu de la _i_-ème case du bloc situé
      à l'adresse _p_,

    - _write_block(p, i, v)_, qui écrit la valeur _v_ dans la _i_-ème case du
      bloc situé à l'adresse _p_.
*** Représentation des références
    La première question à se poser lorsqu'on cherche à traduire un type de
    donnée est celle de sa représentation sous forme de bloc Hobix.

    On peut faire un choix simple : une référence contenant la valeur _v_ va être
    représentée par un bloc mémoire à un seul champ.

    |--------------|
    | Case 0 : _v_ |
    |--------------|
*** Traduction des lectures
    Comment traduire l'expression Hopix suivante ?

    #+BEGIN_SRC
    !x
    #+END_SRC

    En une expression qui lit la case d'indice 0 du bloc _x_.

    #+BEGIN_SRC
    read_block(x, 0)
    #+END_SRC

    Et l'expression suivante ?

    #+BEGIN_SRC
    !(f x)
    #+END_SRC

    Similairement.

    #+BEGIN_SRC
    read_block(f x, 0)
    #+END_SRC

    Quel est le schéma de traduction général ?

   〚 ! ~e~ 〛= read_block(〚 ~e~ 〛, 0)
*** Traduction des écritures
    Comment traduire l'expression Hopix suivante ?

    #+BEGIN_SRC
    x := 42
    #+END_SRC

    En une expression qui écrit la case d'indice 0 du bloc _x_.

    #+BEGIN_SRC
    write_block(x, 0, 42)
    #+END_SRC

    Et l'expression suivante ?

    #+BEGIN_SRC
    f x := g ()
    #+END_SRC

    Similairement.

    #+BEGIN_SRC
    write_block(f x, 0, g ())
    #+END_SRC

    Quel est le schéma de traduction général ?

   〚 ~e₁~ := ~e₂~ 〛= write_block(〚 ~e₁~ 〛, 0, 〚 ~e₂~ 〛)
*** Traduction de l'assignation
    Comment traduire l'expression Hopix suivante ?

    #+BEGIN_SRC
    ref (f 27)
    #+END_SRC

    En l'allocation de bloc de taille 1 suivie d'une écriture.

    #+BEGIN_SRC
    let x = allocate_block(1);
    write_block(x, 0, f 27);
    x
    #+END_SRC

    Proposer maintenant une traduction du programme ci-dessous.

    #+BEGIN_SRC
    ref x
    #+END_SRC

    On ne peut pas utiliser _x_ comme variable temporaire : la traduction
    ci-dessous est *fausse* et fabrique un tas cyclique.

    #+BEGIN_SRC
    let x = allocate_block(1);
    write_block(x, 0, x);
    x
    #+END_SRC

    Il faut utiliser un autre nom de variable, par exemple _y_.

    #+BEGIN_SRC
    let y = allocate_block(1);
    write_block(y, 0, x)
    #+END_SRC

    Quelles conditions sur la variable à introduire ? Elle doit être /fraîche/,
    c'est à dire, *ici*, ne pas apparaître libre dans ~e~. Cela permet d'éviter
    la confusion entre les variables introduites par le compilateur et celles
    provenant du programme source.

    En pratique, on peut régler facilement ce problème en réservant une infinité
    de noms de variables pour le compilateur. En Hopix, il s'agit des noms
    commençant par un /underscore/, refusées par l'analyseur lexical. À chaque
    fois que le compilateur à besoin d'un nom de variable frais, il lui suffit
    d'incrémenter un compteur global, obtenant un entier N, et d'utiliser le nom
    de variable "_N". La présence d'un /underscore/ assure que "_N" ne peut pas
    apparaître dans le programme source, l'incrémentation du compteur garantit
    l'absence de confusion avec d'autres noms générés précédemment ou
    subséquemment.

    Revenons au schéma de traduction général. Quel est-il ?

    〚 ref ~e~ 〛= let x = allocate_block(1); write_block(x, 0, 〚 ~e~ 〛); x

    où x est frais.
** Élimination de la boucle ~for~
   Maintenant qu'on a vu comment implémenter les références, il est assez facile
   de ramener la boucle ~for~ à une boucle ~while~.

   Comment traduit-on le bout de code suivant ?

   #+BEGIN_SRC
   for x in (1 to 10) {
     print_string "Hello world!\n"
   }
   #+END_SRC

   On traduit en une boucle ~while~ et une référence pour le compteur de boucle.

   #+BEGIN_SRC
   let i = allocate_block(1);
   write_block(i, 0, 1);
   while read_block(i, 0) <= 1 {
     print_string "Hello world!\n";
     write_block(i, 0, read_block(i, 0) + 1)
   }
   #+END_SRC

   Ci-dessus, _i_ doit bien sûr être frais.

   Un cas plus compliqué :

   #+BEGIN_SRC
   let y = ref 10;
   for x in (1 to !y) {
     print_string "Hello world!\n";
     y := !y - 1
   }
   #+END_SRC

   Qu'est-ce que ce programme affiche ? Dix messages "Hello world", comme on peut
   le vérifier via hopixInterpreter.ml. On en déduit la traduction suivante.

   #+BEGIN_SRC
   let y =
     (let z = allocate_block(1);
      write_block(z, 0, 10); z);
   let i = allocate_block(1);
   let f = read_block(y, 0);
   write_block(i, 0, 1);
   while read_block(i, 0) <= f {
     print_string "Hello world!\n";
     write_block(y, 0, read_block(y, 0) - 1);
     write_block(i, 0, read_block(i, 0) + 1)
   }
   #+END_SRC

   Le schéma de traduction général est donc :

   〚 for ~x~ in (~e₁~ to ~e₂~) { ~e~ } 〛=
     let i = allocate_block(1);
     let f = 〚 ~e₂~ 〛;
     write_block(i, 0, 〚 ~e₁~ 〛);
     while read_block(i, 0) <= f {
       〚 ~e~ 〛;
       write_block(i, 0, read_block(i, 0) + 1)
     }

   où i et f sont frais.
** Élimination des types enregistrements
   <<sec:record>>
*** Représentation des types enregistrements
    On rappelle qu'un type enregistrement, en Hopix, est défini par une liste de
    champs, chacun composé d'une étiquette (label) spécifiant son nom et d'un
    type.

    Comment représenter t1 = { ℓ1 : ty1; ...; ℓN: tyN } sous forme de bloc ?  Le
    plus simple est d'utiliser un bloc de taille N. Il faut ensuite décider de la
    position à laquelle stocker chaque champ dans le bloc. On peut par exemple
    décider de conserver l'ordre de déclaration.

    |------+------+------+-----+------|
    | x.ℓ1 | x.ℓ2 | x.ℓ3 | ... | x.ℓN |
    |------+------+------+-----+------|

    On pourrait aussi décider de trier les labels par ordre alphabétique, etc.

    Pour être capable d'accéder à la valeur associée au label ℓ, on doit
    connaître sa position dans le bloc. Une façon simple d'y parvenir est de
    disposer d'un environnement E capable d'associer à ℓ sa position E(ℓ).

    Cet environnement doit être calculé lors de la définition d'un type
    enregistrement. Supposons que la définition suivante ait été écrite.

    #+BEGIN_SRC
    type t1 = { x : int; y : string; }
    #+END_SRC

    Si on choisit de conserver l'ordre des champs, on aura E(x) = 0 et E(y) = 1.
*** Traduction des créations d'enregistrements
    Comment traduire l'expression Hopix suivante ?

    #+BEGIN_SRC
    { y = "toto"; x = 42; }
    #+END_SRC

    En l'allocation de bloc de taille 2 suivie d'écritures.

    #+BEGIN_SRC
    let x = allocate_block(2);
    write_block(x, 1, "toto");
    write_block(x, 0, 42);
    x
    #+END_SRC

    où x est frais.

    Le schéma général est donc le suivant.

    〚 { ℓ₁ = ~e₁~; ...; ℓₖ = ~eₖ~; } 〛(E) =
    let x = allocate_block(k);
    write_block(x, E(ℓ₁), 〚 ~e₁~ 〛);
    ...;
    write_block(x, E(ℓₖ), 〚 ~eₖ~ 〛);
    x

    où x est frais.
*** Traduction des projections
    Comment traduire l'expression Hopix suivante ?

    #+BEGIN_SRC
    r.y
    #+END_SRC

    En la lecture du champ E(y) du bloc numéro 2.

    #+BEGIN_SRC
    read_block(r, 1)
    #+END_SRC

    Le schéma général est donc le suivant.

    〚 ~e~.ℓ 〛(E) = read_block(〚 ~e~ 〛, E(ℓ))
*** Traduction du filtrage de motifs sur les enregistrements
    On en discute à la section suivante, en même temps que les motifs.
** Élimination des types algébriques
*** Représentation des types algébriques
    On rappelle qu'un type algébrique, en Hopix, est défini par une liste de
    paires, chacune composée d'un nom de constructeur et d'une liste de types
    formant les arguments du constructeur.

    Comment représenter t2 = Foo | Bar (int, string) | Baz (int) sous forme de
    bloc ? On peut utiliser un bloc de taille N+1 pour représenter le
    constructeur K, où N est l'arité de constructeur. Le +1 vient de la nécessité
    de stocker un *tag* pour se souvenir du constructeur auquel nous avons
    affaire.

   |-----+-----+-----+-----+-----|
   | Tag | ty1 | ty2 | ... | tyN |
   |-----+-----+-----+-----+-----|

   Comme pour les enregistrements, on a besoin d'associer à chaque constructeur K
   son tag E(K). L'environnement est calculé lors de définition du type somme.
   On peut par exemple choisir d'associer au type t2 défini plus haut
   l'environnement E(Foo) = 0, E(Bar) = 1, E(Baz) = 2.
*** Traduction des constructeurs
    Comment traduire l'expression Hopix suivante ?

    #+BEGIN_SRC
    Bar (22, "coucou")
    #+END_SRC

    En l'allocation de bloc de taille 2 suivie d'écritures.

    #+BEGIN_SRC
    let x = allocate_block(3);
    write_block(x, 0, 1)
    write_block(x, 1, 22);
    write_block(x, 2, "coucou");
    x
    #+END_SRC

    où x est frais.

    Le schéma général est donc le suivant.

    〚 K(~e₁~, ..., ~eₖ~) 〛(E) =
    let x = allocate_block(k + 1);
    write_block(x, 0, E(K));
    write_block(x, 1, 〚 ~e₁~ 〛);
    ...
    write_block(x, k, 〚 ~eₖ~ 〛);
    x
*** Traduction du filtrage de motifs
    On peut traduire le filtrage de motifs (/pattern-matching/) de plusieurs
    manières. Nous nous contenterons aujourd'hui d'une implémentation naïve et
    simple. Une technique beaucoup plus efficace sera abordée au second semestre.

    Comment traduire l'expression Hopix suivante ?

    #+BEGIN_SRC
    switch (f ()) { Foo -> 42 | Bar (x, _) -> x | Baz (y) -> y }
    #+END_SRC

    En une suite de conditionnelles.

    #+BEGIN_SRC
    let z = f ();
    if read_block(z, 0) = 0 then 42
    else if read_block(z, 0) = 1 then (let x = read_block(z, 1); x)
    else if read_block(z, 0) = 2 then (let x = read_block(z, 1); x)
    else true {* jamais atteint *}
    #+END_SRC

    Et maintenant l'expression suivante ?

    #+BEGIN_SRC
    switch (f ()) { Foo | Bar (_, _) -> 0 | Baz (y) -> y + 1 }
    #+END_SRC

    En une suite de conditionnelles.

    #+BEGIN_SRC
    let z = f ();
    if read_block(z, 0) = 0 then 0
    else if read_block(z, 0) = 1 then 0
    else if read_block(z, 0) = 2 then (read_block(z, 1) + 1)
    else true {* jamais atteint *}
    #+END_SRC

    Et enfin l'expression suivante ? (On reprend la définition du type t1 de la
    section sur les [[sec:record][enregistrements]].)

    #+BEGIN_SRC
    switch (f ()) { { y = x; x = "toto"; } -> x | { y = _; x = x; } -> length x }
    #+END_SRC

    Encore une fois, une suite de conditionnelles.

    #+BEGIN_SRC
    let z = f ();
    if read_block(z, 0) = "toto" then (let x = read_block(z, 1); x)
    else if true then (let x = read_block(z, 0); length x)
    else true {* jamais atteint *}
    #+END_SRC

    Le schéma général de traduction du filtrage est plus complexe à décrire que
    celui des constructions précédentes. On peut supposer que la fonction de
    compilation d'un motif produit deux morceaux de code : la condition du ~if~,
    et les liaisons

    L'idée est de compiler chaque clause ~p → e~ vers une paire (~cond~, ~defs~),
    où ~cond~ est une expression et ~defs~ une liste de définitions, de sorte à
    ce que la clause complète soit compilée vers ~if cond then let defs; e else
    ...~, où ~...~ est la compilation des clauses suivantes.

    〚 switch (~e~) { ~p₁~ → ~e₁~ | ... | ~pₙ~ → ~eₙ~ } 〛(E) =
    let x = 〚 ~e~ 〛 in
    if ~c₁~ then ~e₁'~ où (~c₁~, ~e₁'~) = 〚 ~p₁~ 〛(E)(x)
    else ...
    else if ~cₙ~ then ~eₙ'~ où (~cₙ~, ~eₙ'~) = 〚 ~pₙ~ 〛(E)(x)
    else fail ()

    À quoi ressemble la traduction 〚 p 〛(E)(~discr~) ? L'expression ~discr~ est
    l'expression dont on cherche à filtrer le résultat. On se contentera de
    donner deux cas, le motif attrape-tout (/wildcard/) et celui des paires (cas
    particulier des n-uplets et enregistrements).

    〚 ~_~ 〛(E)(~discr~) = (~true~, [])

    〚 ~(p₁, p₂)~ 〛(E)(~discr~) = (~c₁ && c₂~, ~defs₁~ @ ~defs₂~)
    où (~c₁~, ~defs₁~) = 〚 p₁ 〛(E)(~read_block(discr, 0)~)
    et (~c₂~, ~defs₂~) = 〚 p₂ 〛(E)(~read_block(discr, 1)~).
* Cours 11 "" <2019-11-25>
** FAQ Projet
** L'auto-amorçage (bootstrap)
** Les inefficacités dans le compilateur
** Le cours du second semestre
** Examen
** L'expressivité des langages de programmation

* Cours 12 "Explicitation des fermetures et défonctionnalisation" <2019-12-02>
** Introduction
   On a vu lors des séances précédentes une transformation essentielle, dite
   d'*explicitation des fermetures*, aujourd'hui on va discuter d'une
   transformation liée, la *défonctionnalisation*.
** Retour sur l'explicitation des fermetures
   On a vu que l'explicitation des fermetures ramène un langage d'ordre
   supérieur à un langage disposant uniquement de pointeurs de fonctions. Dans
   flap, nous l'avons implémentée comme une transformation de Hobix en Fopix.

   Aujourd'hui, on va plutôt essayer de voir cette fonction une traduction
   source à source d'un programme, disons, OCaml dans lui même.
*** Rappels
    Par exemple, considérons le programme suivant.

    #+BEGIN_SRC ocaml
    let f x =
      let y = x + 1 in
      let z = x * 4 in
      fun k -> y + z + k

    let g h =
      h (x + 1) 2
    #+END_SRC

    On peut expliciter ses fermetures pour obtenir le code ci-dessous.

    #+BEGIN_SRC ocaml
    let f_trad x =
      let y = x + 1 in
      let z = x * 4 in
      ((y, z), fun ((y, z), k) -> y + z + k)

    let g_trad x =
      let env, f_body = f_trad (x + 1) in
      f_body (env, 2)
    #+END_SRC

    Notons qu'on a déjà un peu triché en supposant que ~f~ lui même n'était pas
    représentée par une fermeture, une simplification qu'on peut toujours faire
    lorsqu'on considère une fonction top-level et donc nécessairement close.

    Quels sont les types de ces deux fonctions ?

    #+BEGIN_SRC
    $ ocamlc -i defunc.ml
    val f : int -> int -> int
    val g : int -> int
    val f_trad : int -> (int * int) * ((int * int) * int -> int)
    val g_trad : int -> int
    #+END_SRC
*** Typage
    Ajoutons maintenant au programme la fonction ~h~ donnée ci-dessous.

    #+BEGIN_SRC ocaml
    let h x c =
      if c then f x else fun y -> x + y
    #+END_SRC

    En suivant le même schéma, on obtient :

    #+BEGIN_SRC ocaml
    let h_trad x c =
      if c then f_trad x else (x, fun (x, y) -> x + y)
    #+END_SRC

    Ce code est tout à fait correct, au sens où il va s'exécuter sans erreur et
    avoir la même sémantique que le programme source, mais il est *mal typé*. Le
    compilateur OCaml renvoie l'erreur ci-dessous.

    #+BEGIN_SRC
    $ ocamlc -i defunc.ml
    File "defunc.ml", line 26, characters 27-28:
    26 |   if c then f_trad x else (x, fun (x, y) -> x + y)
                                    ^
    Error: This expression has type int but an expression was expected of type
             int * int
    #+END_SRC

    On peut comprendre le problème en remarquant que les deux sous-expressions
    ~f x~ et ~fun y -> x + y~ sont toutes les deux de type ~int -> int~, mais
    sont traduites vers des expressions ayant des types différents : ~(int *
    int) * ((int * int) * int -> int~ dans le premier cas, et ~(int * (int * int
    -> int))~ dans le second.

    Cette différence reflète le fait que notre traduction échoue à *préserver
    les types*. On dit qu'une traduction préserve les types lorsqu'elle associe
    à chaque type τ du source un type traduit unique 〚 τ 〛, et que la
    traduction d'une expression /e/ : τ est une expression 〚 /e/ 〛 : 〚 τ 〛.

    Dans le cas qui nous occupe, il est impossible de définir 〚 τ₁ → τ₂ 〛 car
    le type d'une clôture mentionne le type de l'environnement, qui peut être
    arbitraire (il n'entretien aucun rapport avec τ₁ et τ₂).

    Pour pallier ce défaut, il faut réussir à cacher le type de l'environnement.
    Autrement dit, on cherche un type ~('a, 'b) closure~ tel que 〚 τ₁ → τ₂ 〛
    soit égal à ~(〚 τ₁ 〛, 〚 τ₂ 〛) closure~, et qui dispose des opérations
    spécifiées par la signature ci-dessous.

    #+BEGIN_SRC ocaml
    type ('a, 'b) closure
    val make : ('env, ('env * 'a -> 'b)) -> ('a, 'b) closure
    val apply : (('a, 'b) closure, 'a) -> 'b
    #+END_SRC

    Avec une telle interface, on peut traduire le programme précédent.

    #+BEGIN_SRC ocaml
    let f_trad x =
      let y = x + 1 in
      let z = x * 4 in
      build ((y, z), fun ((y, z), k) -> y + z + k)

    let g_trad x =
      apply (f_trad (x + 1), 2)

    let h_trad x c =
      if c then f_trad x else build (x, fun (x, y) -> x + y)
    #+END_SRC

    Maintenant, connaissez-vous une façon d'implémenter l'interface, en OCaml ?

    La solution est d'utiliser un type abstrait/existentiel, qui en OCaml sont
    des cas particuliers des types de données algébriques généralisés (GADT).

    #+BEGIN_SRC ocaml
    type (_, _) closure =
    | Clo : ('env * (('env * 'a) -> 'b)) -> ('a, 'b) closure

    let make (env, body) = Clo (env, body)

    let apply (clo, x) =
      let Clo (env, body) = clo in
      body (env, x)
    #+END_SRC

    Une telle approche a l'avantage de générer du code typé. C'est nécessaire si
    votre compilateur maintient des représentations intermédiaires typées, à
    l'inverse de flap. On peut aussi remarquer que la seconde traduction est
    plus abstraite, en un sens précis : le GADT va protéger l'environnement de
    la clôture de certaines manipulations.

    Observons par exemple les fonctions ~m~ et ~n~ ci-dessous.

    #+BEGIN_SRC ocaml
    let m x =
      let y = x in
      fun z -> z + y + y

    let n x =
      let y = 2 * x in
      fun z -> z + y
    #+END_SRC

    Elles sont observationnellement équivalentes : aucun programme OCaml ne peut
    distinguer l'une de l'autre. Un compilateur peut donc remplacer tout appel à
    ~m~ par un appel à ~g~, et vice-versa. Maintenant, considérons leur version
    traduite naïvement (sans abstraire les environnements).

    #+BEGIN_SRC ocaml
    let m_trad x =
      let y = x in
      (y, fun (y, z) -> z + y + y)

    let n_trad x =
      let y = 2 * x in
      (y, fun (y, z) -> z + y)
    #+END_SRC

    Est-ce encore vrai qu'on peut toujours remplacer ~m_trad~ par ~n_trad~ et
    vice-versa ? Non ! La fonction suivante renvoie un résultat différent selon
    si on lui passe l'une ou l'autre des fonctions traduites.

    #+BEGIN_SRC ocaml
    let separate m_or_n =
      let (env, body) = m_or_n 1 in
      let x = body (1, 0) in
      if x = 2 then "m_trad" else "n_trad"
    #+END_SRC

    Une telle fonction ne peut pas être programmée si le type des environnements
    est abstrait : ~separate~ ne saurait pas qu'il s'agit d'un entier.
** Défonctionnalisation
   L'explicitation des fermetures exige du langage cible qu'il dispose de
   pointeurs de fonction. Certains langages en sont dépourvu, comme par exemple
   Pascal. C'est également le cas des langages de description de circuits
   électroniques, si l'on accepte de les voir comme des langages de
   programmation (certes très contraints).

   Peut-on se passer des pointeurs de fonction dans les fermetures ? La réponse
   est oui, bien que ce soit au prix d'une forme de modularité.

    #+BEGIN_SRC ocaml
    type clo =
      | F_clo of int * int
      | H_clo of int

    let apply clo arg =
      match clo with
      | F_clo (y, z) ->
         arg + y + z
      | H_clo y ->
         arg + y

    let f_trad x =
      let y = x + 1 in
      let z = x * 4 in
      F_clo (y, z)

    let h_trad x c =
      if c then f x else H_clo x
    #+END_SRC

    Cette traduction, la *défonctionnalisation*, est globale : il faut collecter
    les corps de toutes les fonctions anonymes du programme pour les ajouter à
    la fonction ~apply~ et à la définition du type des fermetures.

    On peut aussi remarquer une autre difficulté si on cherche à formuler une
    traduction respectant les types. Comment traduire le programme suivant ?

    #+BEGIN_SRC ocaml
    let p x =
      let y = x + 2 in
      fun c -> if c then y else 27

    let q x =
      let y = 3 * x in
      fun z -> z < y
    #+END_SRC

    La tentative ci-dessous est mal typée.

    #+BEGIN_SRC ocaml
    type closure =
      | P_clo of int
      | Q_clo of int

    let p_trad x =
      let y = x + 2 in
      P_clo y

    let q_trad x =
      Q_clo x

    let apply clo arg =
      match clo with
      | P_clo y ->
         if arg then y else 27
      | Q_clo x ->
         arg < x                    (* mal typé ! *)
    #+END_SRC

    On pourrait s'en sortir en produisant une fonction ~apply~ et un type
    ~closure~ séparés par type flèche concret, donc un pour ~bool -> int~ et un
    pour ~int -> bool~. Une telle solution suppose qu'il existe un nombre fini
    de types concrets dans un programme, ce qui n'est pas vrai dans certains
    langages suffisamment expressifs (par exemple, en présence de récursion
    polymorphe).

    Une solution beaucoup plus élégante est fournie par les GADTs, une fois de
    plus, cf. le code ci-dessous.

    #+BEGIN_SRC ocaml
    type (_, _) closure =
      | P_clo : int -> (bool, int) closure
      | Q_clo : int -> (int, bool) closure

    let apply : type a b. (a, b) closure -> a -> b =
      fun clo arg ->
      match clo with
      | P_clo y ->
         if arg then y else 27
      | Q_clo x ->
         arg < x

    let p_trad x =
      let y = x + 2 in
      P_clo y

    let q_trad x =
      Q_clo x
    #+END_SRC
